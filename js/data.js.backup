
/* Data Management Module - Firebase Integration */

/**
 * Get tasks from Firebase
 * @returns {Promise<Array>} Promise that resolves with array of task objects
 */
async function getTasks() {
    try {
        const tasksData = await firebaseGet('tasks');
        if (!tasksData) {
            return [];
        }
        
        // Convert Firebase object to array
        const tasksArray = Object.keys(tasksData).map(key => ({
            ...tasksData[key],
            id: tasksData[key].id || key
        }));
        
        return tasksArray;
    } catch (error) {
        console.error('Error getting tasks:', error);
        // Fallback to localStorage
        const tasksJson = localStorage.getItem('tasks');
        return tasksJson ? JSON.parse(tasksJson) : [];
    }
}

/**
 * Save tasks to Firebase
 * @param {Array} tasks - Array of task objects
 * @returns {Promise} Promise that resolves when tasks are saved
 */
async function saveTasks(tasks) {
    try {
        // Convert array to object with task IDs as keys
        const tasksObject = {};
        tasks.forEach(task => {
            tasksObject[task.id] = task;
        });
        
        await firebaseSave('tasks', tasksObject);
        
        // Also save to localStorage as backup
        localStorage.setItem('tasks', JSON.stringify(tasks));
    } catch (error) {
        console.error('Error saving tasks:', error);
        // Fallback to localStorage only
        localStorage.setItem('tasks', JSON.stringify(tasks));
    }
}

/**
 * Get contacts from Firebase
 * @returns {Promise<Array>} Promise that resolves with array of contact objects
 */
async function getContacts() {
    try {
        const contactsData = await firebaseGet('contacts');
        if (!contactsData) {
            return [];
        }
        
        // Convert Firebase object to array
        const contactsArray = Object.keys(contactsData).map(key => ({
            ...contactsData[key],
            id: contactsData[key].id || key
        }));
        
        return contactsArray;
    } catch (error) {
        console.error('Error getting contacts:', error);
        // Fallback to localStorage
        const contactsJson = localStorage.getItem('contacts');
        return contactsJson ? JSON.parse(contactsJson) : [];
    }
}

/**
 * Save contacts to Firebase
 * @param {Array} contacts - Array of contact objects
 * @returns {Promise} Promise that resolves when contacts are saved
 */
async function saveContacts(contacts) {
    try {
        // Convert array to object with contact IDs as keys
        const contactsObject = {};
        contacts.forEach(contact => {
            contactsObject[contact.id] = contact;
        });
        
        await firebaseSave('contacts', contactsObject);
        
        // Also save to localStorage as backup
        localStorage.setItem('contacts', JSON.stringify(contacts));
    } catch (error) {
        console.error('Error saving contacts:', error);
        // Fallback to localStorage only
        localStorage.setItem('contacts', JSON.stringify(contacts));
    }
}

/**
 * Create a new task
 * @param {Object} taskData - Task data object
 * @returns {Promise<Object>} Promise that resolves with created task object
 */
async function createTask(taskData) {
    const task = {
        id: generateId(),
        title: taskData.title,
        description: taskData.description || '',
        category: taskData.category,
        dueDate: taskData.dueDate,
        priority: taskData.priority,
        status: taskData.status || 'to-do',
        assignedTo: taskData.assignedTo || [],
        subtasks: taskData.subtasks || [],
        createdAt: new Date().toISOString(),
        createdBy: getCurrentUser()?.id || 'guest',
        updatedAt: new Date().toISOString()
    };
    
    const tasks = await getTasks();
    tasks.push(task);
    await saveTasks(tasks);
    
    return task;
}

/**
 * Update an existing task
 * @param {string} taskId - Task ID
 * @param {Object} updates - Object containing fields to update
 * @returns {Promise<Object|null>} Promise that resolves with updated task object or null if not found
 */
async function updateTask(taskId, updates) {
    const tasks = await getTasks();
    const taskIndex = tasks.findIndex(task => task.id === taskId);
    
    if (taskIndex === -1) {
        return null;
    }
    
    // Update the task
    tasks[taskIndex] = {
        ...tasks[taskIndex],
        ...updates,
        updatedAt: new Date().toISOString()
    };
    
    await saveTasks(tasks);
    return tasks[taskIndex];
}

/**
 * Delete a task
 * @param {string} taskId - Task ID
 * @returns {Promise<boolean>} Promise that resolves with true if task was deleted, false if not found
 */
async function deleteTask(taskId) {
    const tasks = await getTasks();
    const initialLength = tasks.length;
    const filteredTasks = tasks.filter(task => task.id !== taskId);
    
    if (filteredTasks.length !== initialLength) {
        await saveTasks(filteredTasks);
        return true;
    }
    
    return false;
}

/**
 * Get task by ID
 * @param {string} taskId - Task ID
 * @returns {Promise<Object|null>} Promise that resolves with task object or null if not found
 */
async function getTaskById(taskId) {
    const tasks = await getTasks();
    return tasks.find(task => task.id === taskId) || null;
}

/**
 * Get tasks by status
 * @param {string} status - Task status
 * @returns {Promise<Array>} Promise that resolves with array of tasks with the specified status
 */
async function getTasksByStatus(status) {
    const tasks = await getTasks();
    return tasks.filter(task => task.status === status);
}

/**
 * Create a new contact
 * @param {Object} contactData - Contact data object
 * @returns {Promise<Object>} Promise that resolves with created contact object
 */
async function createContact(contactData) {
    const contact = {
        id: generateId(),
        name: contactData.name,
        email: contactData.email,
        phone: contactData.phone,
        initials: generateInitials(contactData.name),
        color: generateAvatarColor(),
        userId: null,
        createdAt: new Date().toISOString(),
        createdBy: getCurrentUser()?.id || 'guest'
    };
    
    const contacts = await getContacts();
    contacts.push(contact);
    await saveContacts(contacts);
    
    return contact;
}

/**
 * Update an existing contact
 * @param {string} contactId - Contact ID
 * @param {Object} updates - Object containing fields to update
 * @returns {Promise<Object|null>} Promise that resolves with updated contact object or null if not found
 */
async function updateContact(contactId, updates) {
    const contacts = await getContacts();
    const contactIndex = contacts.findIndex(contact => contact.id === contactId);
    
    if (contactIndex === -1) {
        return null;
    }
    
    // Update initials if name changed
    if (updates.name && updates.name !== contacts[contactIndex].name) {
        updates.initials = generateInitials(updates.name);
    }
    
    // Update the contact
    contacts[contactIndex] = {
        ...contacts[contactIndex],
        ...updates
    };
    
    await saveContacts(contacts);
    return contacts[contactIndex];
}

/**
 * Delete a contact
 * @param {string} contactId - Contact ID
 * @returns {Promise<boolean>} Promise that resolves with true if contact was deleted, false if not found
 */
async function deleteContact(contactId) {
    const contacts = await getContacts();
    const initialLength = contacts.length;
    const filteredContacts = contacts.filter(contact => contact.id !== contactId);
    
    if (filteredContacts.length !== initialLength) {
        await saveContacts(filteredContacts);
        
        // Remove contact from all task assignments
        await removeContactFromTasks(contactId);
        
        return true;
    }
    
    return false;
}

/**
 * Remove contact from all task assignments
 * @param {string} contactId - Contact ID to remove
 * @returns {Promise} Promise that resolves when operation is complete
 */
async function removeContactFromTasks(contactId) {
    const tasks = await getTasks();
    let tasksUpdated = false;
    
    tasks.forEach(task => {
        if (task.assignedTo && task.assignedTo.includes(contactId)) {
            task.assignedTo = task.assignedTo.filter(id => id !== contactId);
            task.updatedAt = new Date().toISOString();
            tasksUpdated = true;
        }
    });
    
    if (tasksUpdated) {
        await saveTasks(tasks);
    }
}

/**
 * Get contact by ID
 * @param {string} contactId - Contact ID
 * @returns {Promise<Object|null>} Promise that resolves with contact object or null if not found
 */
async function getContactById(contactId) {
    const contacts = await getContacts();
    return contacts.find(contact => contact.id === contactId) || null;
}

/**
 * Get contacts sorted alphabetically
 * @returns {Promise<Object>} Promise that resolves with contacts grouped by first letter
 */
async function getContactsGrouped() {
    const contacts = await getContacts();
    const sorted = contacts.sort((a, b) => a.name.localeCompare(b.name));
    
    const grouped = {};
    sorted.forEach(contact => {
        const firstLetter = contact.name.charAt(0).toUpperCase();
        if (!grouped[firstLetter]) {
            grouped[firstLetter] = [];
        }
        grouped[firstLetter].push(contact);
    });
    
    return grouped;
}

/**
 * Search tasks by title and description
 * @param {string} searchTerm - Search term
 * @returns {Promise<Array>} Promise that resolves with array of matching tasks
 */
async function searchTasks(searchTerm) {
    const tasks = await getTasks();
    const term = searchTerm.toLowerCase().trim();
    
    if (!term) {
        return tasks;
    }
    
    return tasks.filter(task => 
        task.title.toLowerCase().includes(term) ||
        task.description.toLowerCase().includes(term)
    );
}

/**
 * Get task statistics for summary page
 * @returns {Promise<Object>} Promise that resolves with object containing task statistics
 */
async function getTaskStatistics() {
    const tasks = await getTasks();
    
    const stats = {
        total: tasks.length,
        todo: tasks.filter(task => task.status === 'to-do').length,
        inProgress: tasks.filter(task => task.status === 'in-progress').length,
        awaitFeedback: tasks.filter(task => task.status === 'await-feedback').length,
        done: tasks.filter(task => task.status === 'done').length,
        urgent: tasks.filter(task => task.priority === 'urgent').length,
        nextDeadline: null
    };
    
    // Find next deadline for urgent tasks
    const urgentTasks = tasks.filter(task => 
        task.priority === 'urgent' && 
        task.status !== 'done' &&
        task.dueDate
    );
    
    if (urgentTasks.length > 0) {
        const sortedByDate = urgentTasks.sort((a, b) => 
            new Date(a.dueDate) - new Date(b.dueDate)
        );
        stats.nextDeadline = sortedByDate[0].dueDate;
    }
    
    return stats;
}

/**
 * Toggle subtask completion
 * @param {string} taskId - Task ID
 * @param {string} subtaskId - Subtask ID
 * @returns {Promise<Object|null>} Promise that resolves with updated task object or null if not found
 */
async function toggleSubtask(taskId, subtaskId) {
    const tasks = await getTasks();
    const task = tasks.find(t => t.id === taskId);
    
    if (!task || !task.subtasks) {
        return null;
    }
    
    const subtask = task.subtasks.find(st => st.id === subtaskId);
    if (!subtask) {
        return null;
    }
    
    subtask.completed = !subtask.completed;
    task.updatedAt = new Date().toISOString();
    
    await saveTasks(tasks);
    return task;
}

/**
 * Initialize demo tasks if none exist
 * @returns {Promise} Promise that resolves when initialization is complete
 */
async function initializeDemoTasks() {
    const tasks = await getTasks();
    
    if (tasks.length === 0) {
        const demoTasks = [
            {
                id: 'task_demo_1',
                title: 'CSS Architecture Planning',
                description: 'Define CSS naming conventions, create style guide, and establish component structure for scalable styling.',
                category: 'Technical Task',
                dueDate: '2024-12-25',
                priority: 'medium',
                status: 'in-progress',
                assignedTo: ['user_demo_1', 'user_demo_2'],
                subtasks: [
                    {
                        id: 'subtask_1',
                        title: 'Research CSS methodologies',
                        completed: true
                    },
                    {
                        id: 'subtask_2',
                        title: 'Create style guide document',
                        completed: false
                    },
                    {
                        id: 'subtask_3',
                        title: 'Set up component library',
                        completed: false
                    }
                ],
                createdAt: new Date().toISOString(),
                createdBy: 'user_demo_1',
                updatedAt: new Date().toISOString()
            },
            {
                id: 'task_demo_2',
                title: 'User Registration Flow',
                description: 'Implement complete user registration with validation, email verification, and welcome sequence.',
                category: 'User Story',
                dueDate: '2024-12-20',
                priority: 'urgent',
                status: 'to-do',
                assignedTo: ['user_demo_1'],
                subtasks: [
                    {
                        id: 'subtask_4',
                        title: 'Design registration form',
                        completed: false
                    },
                    {
                        id: 'subtask_5',
                        title: 'Add form validation',
                        completed: false
                    }
                ],
                createdAt: new Date().toISOString(),
                createdBy: 'user_demo_1',
                updatedAt: new Date().toISOString()
            },
            {
                id: 'task_demo_3',
                title: 'Database Optimization',
                description: 'Optimize database queries and implement caching for better performance.',
                category: 'Technical Task',
                dueDate: '2024-12-30',
                priority: 'low',
                status: 'await-feedback',
                assignedTo: ['user_demo_2'],
                subtasks: [],
                createdAt: new Date().toISOString(),
                createdBy: 'user_demo_2',
                updatedAt: new Date().toISOString()
            },
            {
                id: 'task_demo_4',
                title: 'Mobile App Testing',
                description: 'Comprehensive testing of mobile app functionality across different devices and operating systems.',
                category: 'User Story',
                dueDate: '2024-12-15',
                priority: 'medium',
                status: 'done',
                assignedTo: ['user_demo_1', 'user_demo_2'],
                subtasks: [
                    {
                        id: 'subtask_6',
                        title: 'iOS testing',
                        completed: true
                    },
                    {
                        id: 'subtask_7',
                        title: 'Android testing',
                        completed: true
                    }
                ],
                createdAt: new Date().toISOString(),
                createdBy: 'user_demo_2',
                updatedAt: new Date().toISOString()
            }
        ];
        
        await saveTasks(demoTasks);
        console.log('Demo tasks initialized');
    }
}

/**
 * Initialize demo contacts if none exist
 * @returns {Promise} Promise that resolves when initialization is complete
 */
async function initializeDemoContacts() {
    const contacts = await getContacts();
    
    if (contacts.length === 0) {
        const demoContacts = [
            {
                id: 'contact_demo_1',
                name: 'Sofia Müller',
                email: 'sofia@gmail.com',
                phone: '+49 1111 11 111',
                initials: 'SM',
                color: '#FF5EB3',
                userId: null,
                createdAt: new Date().toISOString(),
                createdBy: 'user_demo_1'
            },
            {
                id: 'contact_demo_2',
                name: 'Marcel Bauer',
                email: 'marcel@gmail.com',
                phone: '+49 2222 22 222',
                initials: 'MB',
                color: '#1FD7C1',
                userId: null,
                createdAt: new Date().toISOString(),
                createdBy: 'user_demo_1'
            },
            {
                id: 'contact_demo_3',
                name: 'Benedikt Ziegler',
                email: 'benedikt@gmail.com',
                phone: '+49 3333 33 333',
                initials: 'BZ',
                color: '#462F8A',
                userId: null,
                createdAt: new Date().toISOString(),
                createdBy: 'user_demo_2'
            }
        ];
        
        await saveContacts(demoContacts);
        console.log('Demo contacts initialized');
    }
}

/**
 * Initialize all demo data
 * @returns {Promise} Promise that resolves when all initialization is complete
 */
async function initializeDemoData() {
    await initializeDemoTasks();
    await initializeDemoContacts();
}

// Initialize demo data when DOM is loaded
document.addEventListener('DOMContentLoaded', async function() {
    try {
        await initializeDemoData();
        console.log('✅ All demo data initialized');
    } catch (error) {
        console.error('❌ Error initializing demo data:', error);
    }
});
